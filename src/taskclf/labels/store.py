"""Label span I/O, validation, and synthetic label generation."""

from __future__ import annotations

import datetime as dt
from pathlib import Path
from typing import Final, Sequence

import pandas as pd

from taskclf.core.store import read_parquet, write_parquet
from taskclf.core.types import LabelSpan

# Deterministic app_id -> label mapping aligned with features/build._DUMMY_APPS.
_APP_LABEL_MAP: Final[dict[str, str]] = {
    "com.apple.Terminal": "coding",
    "org.mozilla.firefox": "browsing_research",
    "com.microsoft.VSCode": "coding",
    "com.apple.mail": "messaging_email",
    "us.zoom.xos": "meetings_calls",
    "com.tinyspeck.slackmacgap": "messaging_email",
    "com.google.Chrome": "browsing_research",
    "com.jetbrains.intellij": "coding",
    "com.apple.finder": "break_idle",
    "com.apple.Notes": "writing_docs",
}

_DUMMY_APPS_ORDER: Final[list[str]] = [
    "com.apple.Terminal",
    "org.mozilla.firefox",
    "com.microsoft.VSCode",
    "com.apple.mail",
    "us.zoom.xos",
    "com.tinyspeck.slackmacgap",
    "com.google.Chrome",
    "com.jetbrains.intellij",
    "com.apple.finder",
    "com.apple.Notes",
]


def write_label_spans(spans: Sequence[LabelSpan], path: Path) -> Path:
    """Serialize *spans* to a parquet file at *path*.

    Args:
        spans: Label span instances to persist.
        path: Destination parquet file path.

    Returns:
        The *path* that was written.
    """
    df = pd.DataFrame([s.model_dump() for s in spans])
    return write_parquet(df, path)


def read_label_spans(path: Path) -> list[LabelSpan]:
    """Deserialize label spans from a parquet file.

    Args:
        path: Path to an existing parquet file written by
            :func:`write_label_spans`.

    Returns:
        List of validated ``LabelSpan`` instances.
    """
    df = read_parquet(path)
    return [LabelSpan.model_validate(row) for row in df.to_dict(orient="records")]


def generate_dummy_labels(date: dt.date, n_rows: int = 10) -> list[LabelSpan]:
    """Create synthetic label spans aligned to the dummy feature timestamps.

    Each span covers exactly one minute bucket, mirroring the timestamps
    generated by ``features.build.generate_dummy_features`` so that every
    feature row has a covering label.

    Args:
        date: Calendar date to generate spans for.
        n_rows: Number of one-minute spans to create.

    Returns:
        List of ``LabelSpan`` instances with provenance ``"synthetic"``.
    """
    spans: list[LabelSpan] = []
    for i in range(n_rows):
        hour = 9 + (i * 8 // max(n_rows, 1))
        minute = (i * 7) % 60
        start = dt.datetime(date.year, date.month, date.day, hour, minute)
        end = start + dt.timedelta(seconds=60)

        app_id = _DUMMY_APPS_ORDER[i % len(_DUMMY_APPS_ORDER)]
        label = _APP_LABEL_MAP[app_id]

        spans.append(
            LabelSpan(
                start_ts=start,
                end_ts=end,
                label=label,
                provenance="synthetic",
            )
        )
    return spans
